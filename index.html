<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#4285f4">
    <title>PDF to EPUB Converter</title>
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --primary-color: #4285f4;
            --secondary-color: #34a853;
            --accent-color: #fbbc05;
            --error-color: #ea4335;
            --text-color: #202124;
            --bg-color: #ffffff;
            --card-bg: #f8f9fa;
            --border-color: #dadce0;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary-color: #8ab4f8;
                --secondary-color: #81c995;
                --accent-color: #fdd663;
                --error-color: #f28b82;
                --text-color: #e8eaed;
                --bg-color: #202124;
                --card-bg: #303134;
                --border-color: #5f6368;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 0.5rem;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border-color);
        }

        .steps-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .step {
            opacity: 0.6;
            transition: opacity 0.3s;
        }

        .step.active {
            opacity: 1;
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .step-number {
            background-color: var(--primary-color);
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }

        .step-title {
            font-size: 1.2rem;
            font-weight: 600;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--primary-color);
            opacity: 0.9;
        }

        button:disabled {
            background-color: var(--border-color);
            cursor: not-allowed;
        }

        .file-upload {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .file-upload:hover {
            border-color: var(--primary-color);
        }

        .file-upload input {
            display: none;
        }

        .text-editor {
            width: 100%;
            min-height: 400px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            resize: vertical;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .progress-container {
            margin-top: 10px;
            width: 100%;
            background-color: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 5px;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.3s;
        }

        .metadata-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px 15px;
            margin-bottom: 15px;
        }

        .metadata-grid label {
            font-weight: 600;
        }

        .metadata-grid input, .metadata-grid textarea {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px;
            font-family: inherit;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .chapter-container {
            margin-bottom: 15px;
        }

        .chapter-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .chapter-item {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chapter-item:last-child {
            border-bottom: none;
        }

        .chapter-actions {
            display: flex;
            gap: 5px;
        }

        .small-button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--bg-color);
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .close-button {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 20px;
            background-color: var(--primary-color);
            color: white;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .notification.show {
            opacity: 1;
        }

        .notification.error {
            background-color: var(--error-color);
        }

        .install-prompt {
            display: none;
            margin-bottom: 15px;
            padding: 10px;
            background-color: var(--accent-color);
            color: var(--text-color);
            border-radius: 4px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .options-grid {
                grid-template-columns: 1fr;
            }
        }

        .split-editor {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .chapter-preview {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 15px;
            background-color: var(--card-bg);
            max-height: 200px;
            overflow-y: auto;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .button-with-spinner {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .spinner-visible {
            display: inline-block;
        }

        .spinner-hidden {
            display: none;
        }

        .content-type-selector {
            margin-bottom: 15px;
        }

        .section-type {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <header>
        <h1>PDF to EPUB Converter</h1>
        <p>Converti facilmente i tuoi file PDF in EPUB con supporto per la modifica del testo estratto</p>
    </header>

    <div class="install-prompt" id="installPrompt">
        <p>Puoi installare questa applicazione sul tuo dispositivo per usarla offline!</p>
        <button id="installButton">Installa App</button>
    </div>

    <div class="app-container">
        <div class="steps-container">
            <div class="step active" id="step1">
                <div class="card">
                    <div class="step-header">
                        <div class="step-number">1</div>
                        <div class="step-title">Carica il tuo file PDF</div>
                    </div>
                    <div class="file-upload" id="dropArea">
                        <input type="file" id="pdfFile" accept=".pdf" />
                        <p>Trascina qui il tuo file PDF o clicca per selezionarlo</p>
                        <p><small>Dimensione massima: 100MB</small></p>
                    </div>
                    <div id="fileInfo" style="margin-top: 10px; display: none;">
                        <p>File: <span id="fileName"></span></p>
                        <p>Dimensione: <span id="fileSize"></span></p>
                    </div>
                    <div class="progress-container" id="progressContainer" style="display: none;">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                </div>
            </div>

            <div class="step" id="step2">
                <div class="card">
                    <div class="step-header">
                        <div class="step-number">2</div>
                        <div class="step-title">Analizza e modifica il testo estratto</div>
                    </div>
                    <div class="options-grid">
                        <div class="option-item">
                            <input type="checkbox" id="removePageNumbers" checked />
                            <label for="removePageNumbers">Rimuovi numeri di pagina</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="removeHeadersFooters" checked />
                            <label for="removeHeadersFooters">Rimuovi intestazioni/piè di pagina</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="detectChapters" checked />
                            <label for="detectChapters">Rileva capitoli automaticamente</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="recognizeMetadata" checked />
                            <label for="recognizeMetadata">Riconosci metadati (titolo, autore)</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="fixHyphenation" checked />
                            <label for="fixHyphenation">Ripara sillabazione</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="preserveLineBreaks" checked />
                            <label for="preserveLineBreaks">Preserva interruzioni di riga</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="detectSpecialSections" checked />
                            <label for="detectSpecialSections">Rileva sezioni speciali</label>
                        </div>
                       <div class="option-item">
    <input type="checkbox" id="removePageBreaks" checked />
    <label for="removePageBreaks">Mantieni interruzioni di pagina solo ai capitoli</label>
</div>
                    </div>
                    <button id="extractTextBtn" disabled>
                        <span class="loading-spinner spinner-hidden" id="extractSpinner"></span>
                        Estrai testo dal PDF
                    </button>
                </div>
            </div>

            <div class="step" id="step3">
                <div class="card">
                    <div class="step-header">
                        <div class="step-number">3</div>
                        <div class="step-title">Metadati e struttura</div>
                    </div>
                    <div class="metadata-grid">
                        <label for="bookTitle">Titolo:</label>
                        <input type="text" id="bookTitle" placeholder="Titolo del libro" />
                        
                        <label for="bookAuthor">Autore:</label>
                        <input type="text" id="bookAuthor" placeholder="Autore del libro" />
                        
                        <label for="bookLanguage">Lingua:</label>
                        <input type="text" id="bookLanguage" value="it" placeholder="Codice lingua (es. it, en)" />
                        
                        <label for="bookDescription">Descrizione:</label>
                        <textarea id="bookDescription" rows="3" placeholder="Descrizione del libro"></textarea>
                    </div>
                    
                    <div class="chapter-container">
                        <h3>Sezioni rilevate:</h3>
                        <div class="chapter-list" id="chaptersList">
                            <!-- I capitoli verranno aggiunti qui dinamicamente -->
                        </div>
                        <button id="addChapterBtn" class="small-button">Aggiungi sezione</button>
                    </div>
                    
                    <button id="proceedToEditBtn" disabled>Procedi alla modifica del testo</button>
                </div>
            </div>

            <div class="step" id="step4">
                <div class="card">
                    <div class="step-header">
                        <div class="step-number">4</div>
                        <div class="step-title">Modifica il testo</div>
                    </div>
                    <div class="split-editor">
                        <div>
                            <label for="chapterSelect">Seleziona sezione:</label>
                            <select id="chapterSelect">
                                <!-- Le opzioni verranno aggiunte qui dinamicamente -->
                            </select>
                            <div class="content-type-selector" id="contentTypeSelector">
                                <label>Tipo di contenuto:</label>
                                <div class="section-type">
                                    <input type="radio" id="typeNormal" name="contentType" value="normal" checked>
                                    <label for="typeNormal">Testo normale</label>
                                </div>
                                <div class="section-type">
                                    <input type="radio" id="typeChapter" name="contentType" value="chapter">
                                    <label for="typeChapter">Capitolo</label>
                                </div>
                                <div class="section-type">
                                    <input type="radio" id="typeTitle" name="contentType" value="title">
                                    <label for="typeTitle">Titolo</label>
                                </div>
                                <div class="section-type">
                                    <input type="radio" id="typeColophon" name="contentType" value="colophon">
                                    <label for="typeColophon">Colophon</label>
                                </div>
                                <div class="section-type">
                                    <input type="radio" id="typeDedication" name="contentType" value="dedication">
                                    <label for="typeDedication">Dedica</label>
                                </div>
                                <div class="section-type">
                                    <input type="radio" id="typeQuote" name="contentType" value="quote">
                                    <label for="typeQuote">Citazione</label>
                                </div>
                            </div>
                        </div>
                        <textarea id="textEditor" class="text-editor" placeholder="Il testo estratto apparirà qui..."></textarea>
                    </div>
                    <button id="saveTextBtn" disabled>Salva modifiche</button>
                    <button id="generateEpubBtn" style="margin-top: 10px; background-color: var(--secondary-color);">Genera EPUB</button>
                </div>
            </div>

            <div class="step" id="step5">
                <div class="card">
                    <div class="step-header">
                        <div class="step-number">5</div>
                        <div class="step-title">Download EPUB</div>
                    </div>
                    <div style="text-align: center; padding: 20px;">
                        <p>Il tuo file EPUB è pronto!</p>
                        <button id="downloadEpubBtn" style="margin-top: 15px; background-color: var(--secondary-color);">
                            <span class="loading-spinner spinner-hidden" id="generateSpinner"></span>
                            Scarica EPUB
                        </button>
                        <p style="margin-top: 15px;">
                            <button id="startOverBtn" style="background-color: var(--primary-color);">Converti un altro PDF</button>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal per modificare il capitolo -->
    <div class="modal" id="chapterModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Modifica sezione</h3>
                <button class="close-button" id="closeChapterModal">&times;</button>
            </div>
            <div>
                <div style="margin-bottom: 15px;">
                    <label for="chapterTitle">Titolo della sezione:</label>
                    <input type="text" id="chapterTitle" style="width: 100%; margin-top: 5px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px;" placeholder="Titolo della sezione" />
                </div>
                <div style="margin-bottom: 15px;">
                    <label for="chapterStartPosition">Posizione di inizio (carattere):</label>
                    <input type="number" id="chapterStartPosition" style="width: 100%; margin-top: 5px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px;" min="0" />
                </div>
                <div style="margin-bottom: 15px;">
                    <label for="sectionType">Tipo di sezione:</label>
                    <select id="sectionType" style="width: 100%; margin-top: 5px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px;">
                        <option value="normal">Testo normale</option>
                        <option value="chapter">Capitolo</option>
                        <option value="title">Titolo</option>
                        <option value="colophon">Colophon</option>
                        <option value="dedication">Dedica</option>
                        <option value="quote">Citazione</option>
                    </select>
                </div>
                <button id="saveChapterBtn" style="width: 100%;">Salva sezione</button>
            </div>
        </div>
    </div>

    <!-- Notifica -->
    <div class="notification" id="notification"></div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Imposta il worker per PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.worker.min.js';

        // Variabili globali
        let currentPdfFile = null;
        let extractedText = '';
        let pdfDocument = null;
        let chapters = [];
        let currentEditingChapterIndex = -1;
        let epubBlob = null;

        // DOM Elements
        const dropArea = document.getElementById('dropArea');
        const pdfFileInput = document.getElementById('pdfFile');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const extractTextBtn = document.getElementById('extractTextBtn');
        const textEditor = document.getElementById('textEditor');
        const saveTextBtn = document.getElementById('saveTextBtn');
        const generateEpubBtn = document.getElementById('generateEpubBtn');
        const downloadEpubBtn = document.getElementById('downloadEpubBtn');
        const startOverBtn = document.getElementById('startOverBtn');
        const proceedToEditBtn = document.getElementById('proceedToEditBtn');
        const removePageNumbers = document.getElementById('removePageNumbers');
        const removeHeadersFooters = document.getElementById('removeHeadersFooters');
        const detectChapters = document.getElementById('detectChapters');
        const fixHyphenation = document.getElementById('fixHyphenation');
        const preserveLineBreaks = document.getElementById('preserveLineBreaks');
        const detectSpecialSections = document.getElementById('detectSpecialSections');
        const removePageBreaks = document.getElementById('removePageBreaks');
        const bookTitle = document.getElementById('bookTitle');
        const bookAuthor = document.getElementById('bookAuthor');
        const bookLanguage = document.getElementById('bookLanguage');
        const bookDescription = document.getElementById('bookDescription');
        const chaptersList = document.getElementById('chaptersList');
        const addChapterBtn = document.getElementById('addChapterBtn');
        const chapterSelect = document.getElementById('chapterSelect');
        const contentTypeSelector = document.getElementById('contentTypeSelector');
        const chapterModal = document.getElementById('chapterModal');
        const chapterTitle = document.getElementById('chapterTitle');
        const chapterStartPosition = document.getElementById('chapterStartPosition');
        const sectionType = document.getElementById('sectionType');
        const saveChapterBtn = document.getElementById('saveChapterBtn');
        const closeChapterModal = document.getElementById('closeChapterModal');
        const notification = document.getElementById('notification');
        const installPrompt = document.getElementById('installPrompt');
        const installButton = document.getElementById('installButton');
        const extractSpinner = document.getElementById('extractSpinner');
        const generateSpinner = document.getElementById('generateSpinner');

        // Step elements
        const steps = [
            document.getElementById('step1'),
            document.getElementById('step2'),
            document.getElementById('step3'),
            document.getElementById('step4'),
            document.getElementById('step5')
        ];

        // Inizializzazione
        document.addEventListener('DOMContentLoaded', function() {
            // Gestione del drag and drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                dropArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                dropArea.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight() {
                dropArea.style.borderColor = 'var(--primary-color)';
                dropArea.style.backgroundColor = 'rgba(66, 133, 244, 0.1)';
            }
            
            function unhighlight() {
                dropArea.style.borderColor = 'var(--border-color)';
                dropArea.style.backgroundColor = '';
            }
            
            dropArea.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                handleFiles(files);
            }
            
            // Gestione del click su area di upload
            dropArea.addEventListener('click', function() {
                pdfFileInput.click();
            });
            
            pdfFileInput.addEventListener('change', function() {
                handleFiles(this.files);
            });
            
            // Event listeners per i pulsanti
            extractTextBtn.addEventListener('click', extractTextFromPdf);
            proceedToEditBtn.addEventListener('click', goToEditStep);
            saveTextBtn.addEventListener('click', saveTextChanges);
            generateEpubBtn.addEventListener('click', generateEpub);
            downloadEpubBtn.addEventListener('click', downloadEpub);
            startOverBtn.addEventListener('click', resetApp);
            addChapterBtn.addEventListener('click', addNewChapter);
            saveChapterBtn.addEventListener('click', saveChapterChanges);
            closeChapterModal.addEventListener('click', closeModal);
            chapterSelect.addEventListener('change', loadChapterContent);
            
            // Listener per il cambio di tipo di contenuto
            document.querySelectorAll('input[name="contentType"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    updateContentType(this.value);
                });
            });
            
            // Inizializza come PWA
            initPwa();
        });

        // Gestione PWA
        let deferredPrompt;

        function initPwa() {
            // Registra il service worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('service-worker.js')
                    .then(reg => console.log('Service Worker registrato', reg))
                    .catch(err => console.log('Errore nella registrazione del Service Worker', err));
            }

            // Gestisci l'evento di installazione
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                installPrompt.style.display = 'block';
            });

            installButton.addEventListener('click', () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    deferredPrompt.userChoice.then((choiceResult) => {
                        if (choiceResult.outcome === 'accepted') {
                            console.log('Utente ha accettato di installare la PWA');
                        }
                        deferredPrompt = null;
                        installPrompt.style.display = 'none';
                    });
                }
            });

            window.addEventListener('appinstalled', (evt) => {
                console.log('App installata');
                installPrompt.style.display = 'none';
            });
        }

        // Gestione dei file caricati
        function handleFiles(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            
            // Verifica se è un PDF
            if (file.type !== 'application/pdf') {
                showNotification('Per favore, carica un file PDF valido.', true);
                return;
            }
            
            // Verifica la dimensione (100MB max)
            if (file.size > 100 * 1024 * 1024) {
                showNotification('Il file è troppo grande. La dimensione massima è di 100MB.', true);
                return;
            }
            
            // Mostra le informazioni sul file
            currentPdfFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileInfo.style.display = 'block';
            
            // Abilita il pulsante per estrarre il testo
            extractTextBtn.disabled = false;
            
            // Imposta il titolo del libro dal nome del file
            const fileNameWithoutExt = file.name.replace('.pdf', '');
            bookTitle.value = fileNameWithoutExt;
            
            // Attiva il passo 2
            goToStep(1);
        }

        // Estrazione del testo dal PDF
        async function extractTextFromPdf() {
            if (!currentPdfFile) return;
            
            try {
                // Mostra il loader
                extractTextBtn.disabled = true;
                extractSpinner.classList.remove('spinner-hidden');
                extractSpinner.classList.add('spinner-visible');
                
                // Mostra la barra di progresso
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                
                // Carica il PDF
                const arrayBuffer = await readFileAsArrayBuffer(currentPdfFile);
                pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const numPages = pdfDocument.numPages;
            let fullText = '';
            let pageContents = []; // Memorizza il contenuto di ogni pagina separatamente
            
            // Estrai il testo da ogni pagina
            for (let i = 1; i <= numPages; i++) {
                const page = await pdfDocument.getPage(i);
                const textContent = await page.getTextContent();
                
                let pageText = '';
                let lastY, lastItem;
                let currentLine = '';
                let lines = [];
                
                // Combina gli elementi di testo con un'elaborazione migliorata delle linee
                for (const item of textContent.items) {
                    // Se è una nuova riga (coordinata Y diversa)
                    if (lastY !== undefined && Math.abs(lastY - item.transform[5]) > 1) {
                        if (currentLine.trim()) {
                            lines.push(currentLine.trim());
                        }
                        currentLine = item.str;
                    } else if (lastItem && preserveLineBreaks.checked) {
                        // Calcola lo spazio tra gli elementi per determinare se è uno spazio reale
                        const lastTransform = lastItem.transform;
                        const lastWidth = lastItem.width;
                        const lastEndX = lastTransform[4] + lastWidth;
                        const currentStartX = item.transform[4];
                        const spacingThreshold = 3; // Soglia per determinare uno spazio significativo
                        
                        if (currentStartX - lastEndX > spacingThreshold) {
                            currentLine += ' ' + item.str;
                        } else {
                            currentLine += item.str;
                        }
                    } else {
                        currentLine += item.str;
                    }
                    
                    lastY = item.transform[5];
                    lastItem = item;
                }
                
                // Aggiungi l'ultima riga
                if (currentLine.trim()) {
                    lines.push(currentLine.trim());
                }
                
                // Unisci le linee in testo
                pageText = lines.join('\n');
                
                // Applica la pulizia del testo
                pageText = cleanPageText(pageText, i, numPages);
                
                // Memorizza il testo della pagina
                pageContents.push({
                    pageNum: i,
                    content: pageText
                });
                
                // Aggiorna la barra di progresso
                const progress = (i / numPages) * 100;
                progressBar.style.width = `${progress}%`;
            }
            
            // Elabora il testo nel suo insieme
            fullText = processExtractedText(pageContents);
            
            // Pulisci il testo completo
            extractedText = fullText;
            
            // Analizza il testo per i metadati e i capitoli
            analyzeText(extractedText);
            
            // Mostra il passo 3
            goToStep(2);
            
            // Abilita il pulsante per procedere
            proceedToEditBtn.disabled = false;
            
        } catch (error) {
            console.error('Errore nell\'estrazione del testo:', error);
            showNotification('Si è verificato un errore durante l\'estrazione del testo. ' + error.message, true);
        } finally {
            // Nascondi il loader
            extractSpinner.classList.remove('spinner-visible');
            extractSpinner.classList.add('spinner-hidden');
            extractTextBtn.disabled = false;
        }
    }

    // Elabora il testo estratto applicando tutte le opzioni di pulizia
    function processExtractedText(pageContents) {
        let processedText = '';
        let previousPageEndedWithHyphen = false;
        let previousPageLastLine = '';
        
        for (let i = 0; i < pageContents.length; i++) {
            let pageText = pageContents[i].content;
            let pageLines = pageText.split('\n');
            
            // Gestisci l'hyphenation fra le pagine
            if (previousPageEndedWithHyphen && fixHyphenation.checked) {
                if (pageLines.length > 0 && pageLines[0].trim()) {
                    // Rimuovi il trattino e unisci con la prima riga della pagina corrente
                    previousPageLastLine = previousPageLastLine.substring(0, previousPageLastLine.length - 1);
                    pageLines[0] = previousPageLastLine + pageLines[0];
                    
                    // Aggiorna il testo della pagina
                    pageText = pageLines.join('\n');
                    
                    // Se stiamo rimuovendo i page break, dobbiamo aggiornare anche il testo elaborato
                    if (removePageBreaks.checked) {
                        // Rimuovi l'ultima riga del testo elaborato finora
                        processedText = processedText.substring(0, processedText.lastIndexOf('\n'));
                    }
                }
            }
            
            // Controlla se l'ultima riga della pagina termina con un trattino
            if (pageLines.length > 0) {
                previousPageLastLine = pageLines[pageLines.length - 1];
                previousPageEndedWithHyphen = previousPageLastLine.endsWith('-');
            } else {
                previousPageEndedWithHyphen = false;
                previousPageLastLine = '';
            }
            
// Aggiungi il testo della pagina al testo elaborato senza interruzioni di pagina
// (le interruzioni saranno aggiunte solo alla fine dei capitoli)
processedText += (processedText.endsWith('\n') ? '' : '\n') + pageText;
            
        }
        
        // Riparazione della sillabazione all'interno delle pagine
        if (fixHyphenation.checked) {
            processedText = fixInternalHyphenation(processedText);
        }
        
        // Pulizia finale
        processedText = cleanExtractedText(processedText);
        
        return processedText;
    }

    // Riparazione della sillabazione all'interno di una pagina
    function fixInternalHyphenation(text) {
        // Pattern: una riga termina con un trattino e la successiva inizia con una lettera minuscola
        const hyphenPattern = /(\w+)-\n(\w+)/g;
        
        // Sostituisce il pattern unendo le parole sillabate
        return text.replace(hyphenPattern, (match, part1, part2) => {
            // Verifica se la seconda parte inizia con una lettera minuscola (probabile continuazione)
            if (/^[a-zàèìòùáéíóúäëïöüâêîôû]/.test(part2)) {
                return part1 + part2;
            }
            // Altrimenti mantieni il trattino (potrebbe essere un trattino significativo)
            return part1 + '-\n' + part2;
        });
    }

    // Pulizia del testo della pagina
    function cleanPageText(text, pageNum, totalPages) {
        if (!removePageNumbers.checked && !removeHeadersFooters.checked) {
            return text;
        }
        
        // Dividi in linee
        const lines = text.split('\n');
        
        // Filtra le linee
        const filteredLines = lines.filter(line => {
            // Rimuovi numeri di pagina
            if (removePageNumbers.checked) {
                // Numeri di pagina isolati
                if (/^\s*\d+\s*$/.test(line)) {
                    return false;
                }
                
                // Numeri di pagina con formati comuni (Pagina X, Page X, X/Y, ecc.)
                if (/^\s*(Page|Pagina|p\.)\s*\d+\s*$/.test(line) || 
                    new RegExp(`^\\s*${pageNum}\\s*/\\s*${totalPages}\\s*$`).test(line)) {
                    return false;
                }
            }
            
            // Rimuovi intestazioni e piè di pagina
            if (removeHeadersFooters.checked) {
                // Considera le prime e ultime righe come potenziali intestazioni/piè di pagina
                if (lines.length > 3) {
                    // Se è la prima o l'ultima riga della pagina
                    if (lines.indexOf(line) === 0 || lines.indexOf(line) === lines.length - 1) {
                        // Verifica se la riga contiene titoli comuni di capitoli o intestazioni
                        if (!/^(capitolo|chapter|parte|part|sezione|section)\s+(\d+|[IVXLCDM]+)/i.test(line)) {
                            // Verifica se la riga contiene solo il titolo del libro
                            if (bookTitle.value && line.trim() === bookTitle.value.trim()) {
                                return false;
                            }
                            
                            // Verifica se la riga contiene l'autore
                            if (bookAuthor.value && line.trim() === bookAuthor.value.trim()) {
                                return false;
                            }
                            
                            // Verifica se la riga è molto breve (probabile intestazione/piè di pagina)
                            if (line.trim().length < 30) {
                                return false;
                            }
                        }
                    }
                }
            }
            
            return true;
        });
        
        return filteredLines.join('\n');
    }

    // Pulizia del testo estratto completo
    function cleanExtractedText(text) {
        // Rimuovi spazi bianchi multipli
        let cleanText = text.replace(/ {2,}/g, ' ');
        
        // Rimuovi interruzioni di riga ripetute (più di 2)
        cleanText = cleanText.replace(/\n{3,}/g, '\n\n');
        
        // Rimuovi spazi all'inizio e alla fine
        cleanText = cleanText.trim();
        
        return cleanText;
    }

    // Analisi del testo per rilevare metadati e capitoli
    function analyzeText(text) {
        // Rileva il titolo e l'autore dal testo
    if (detectSpecialSections.checked) {
        detectFrontMatterSections(text);
    }
        
   // Rileva capitoli se richiesto
    if (detectChapters.checked) {
        detectChaptersInText(text);
    } else {
        // Altrimenti crea un capitolo unico con tutto il testo
        chapters = [{
            title: 'Intero documento',
            startPosition: 0,
            content: text,
            type: 'normal'
        }];
    }
    
    // Aggiorna l'UI con i capitoli
    updateChaptersList();
}

    // Rileva elementi del frontmatter (titolo, autore, colophon, ecc.)
// Funzione migliorata per rilevare sezioni nel frontmatter
function detectFrontMatterSections(text) {
    // Rileva il titolo del libro
    const titlePattern = /^\s*([A-Z][A-ZÀÈÌÒÙ\s',;:.]{4,60})\s*\n/m;
    const titleMatch = text.match(titlePattern);
    if (titleMatch && titleMatch.index < 500) {
        const title = titleMatch[1].trim();
        if (!bookTitle.value) {
            bookTitle.value = title;
        }
        
        chapters.push({
            title: 'Titolo',
            startPosition: titleMatch.index,
            content: title,
            type: 'title'
        });
    }
    
    // Rileva dediche
    const dedicationPattern = /^\s*(A|To|Dedicato a|Dedicated to)\s+([A-Za-z][a-zA-Zàèìòùé'\s,.]+)$/m;
    const dedicationMatch = text.match(dedicationPattern);
    if (dedicationMatch) {
        const dedicationPos = text.indexOf(dedicationMatch[0]);
        if (dedicationPos > -1) {
            let dedicationEnd = text.indexOf('\n\n', dedicationPos);
            if (dedicationEnd === -1) dedicationEnd = text.indexOf('\n', dedicationPos + dedicationMatch[0].length);
            if (dedicationEnd === -1) dedicationEnd = dedicationPos + dedicationMatch[0].length;
            
            const dedication = text.substring(dedicationPos, dedicationEnd).trim();
            
            chapters.push({
                title: 'Dedica',
                startPosition: dedicationPos,
                content: dedication,
                type: 'dedication'
            });
        }
    }
    
    // Rileva colophon
    const colophonPattern = /(ISBN|edizione|editore|copyright|pubblicato da|printed by|©).*?([0-9]{4})/i;
    const colophonMatch = text.match(colophonPattern);
    if (colophonMatch) {
        const colophonPos = text.indexOf(colophonMatch[0]);
        if (colophonPos > -1) {
            let colophonStart = text.lastIndexOf('\n\n', colophonPos);
            if (colophonStart === -1) colophonStart = text.lastIndexOf('\n', colophonPos);
            if (colophonStart === -1) colophonStart = colophonPos;
            
            let colophonEnd = text.indexOf('\n\n', colophonPos);
            if (colophonEnd === -1) colophonEnd = text.indexOf('\n', colophonPos + colophonMatch[0].length);
            if (colophonEnd === -1) colophonEnd = colophonPos + colophonMatch[0].length + 100;
            colophonEnd = Math.min(colophonEnd, text.length);
            
            const colophon = text.substring(colophonStart, colophonEnd).trim();
            
            chapters.push({
                title: 'Colophon',
                startPosition: colophonStart,
                content: colophon,
                type: 'colophon'
            });
        }
    }
    
    // Rileva citazioni
    const quotePattern = /^[\s>"].*?["—][\s\n]+—\s*[A-Z][a-zA-Zàèìòùé'\s,.]+$/m;
    const quoteMatch = text.match(quotePattern);
    if (quoteMatch) {
        const quotePos = text.indexOf(quoteMatch[0]);
        if (quotePos > -1) {
            let quoteStart = text.lastIndexOf('\n\n', quotePos);
            if (quoteStart === -1) quoteStart = text.lastIndexOf('\n', quotePos);
            if (quoteStart === -1) quoteStart = quotePos;
            
            let quoteEnd = text.indexOf('\n\n', quotePos);
            if (quoteEnd === -1) quoteEnd = text.indexOf('\n', quotePos + quoteMatch[0].length);
            if (quoteEnd === -1) quoteEnd = quotePos + quoteMatch[0].length;
            
            const quote = text.substring(quoteStart, quoteEnd).trim();
            
            chapters.push({
                title: 'Citazione',
                startPosition: quoteStart,
                content: quote,
                type: 'quote'
            });
        }
    }
}

function detectChaptersInText(text) {
    // Inizia con un array vuoto (le sezioni speciali potrebbero essere già state aggiunte)
    if (chapters.length === 0) {
        chapters = [];
    }
    
    // Pattern migliorati per rilevare i titoli dei capitoli
    const chapterPatterns = [
        // Pattern espliciti per capitoli numerati (case-insensitive)
        /\n\s*(Capitolo|Chapter|Cap\.|CAPITOLO)\s+(\d+|[IVXLCDM]+)[\s:.-]*(.*)?\n/gi,
        
        // Pattern per parti o sezioni
        /\n\s*(Parte|Part|Sezione|Section|PARTE|PART)\s+(\d+|[IVXLCDM]+)[\s:.-]*(.*)?\n/gi,
        
        // Pattern per capitoli con solo numeri o numeri romani
        /\n\s*(\d+|[IVXLCDM]+)[\s:.-][\s]*(.*)?\n/gi,
        
        // Pattern per titoli formattati (caratteri non alfanumerici prima/dopo o tutto maiuscolo)
        /\n\s*[*_#]{1,3}\s*([A-Z][^.\n]{5,60})[*_#]{0,3}\s*\n/g,
        
        // Pattern per titoli in maiuscolo isolati
        /\n\s*([A-ZÀÈÌÒÙ][A-ZÀÈÌÒÙ\s',;:.]{4,60})\s*\n/g,
        
        // Pattern per titoli con numeri (es. "1. Introduzione")
        /\n\s*(\d+[\.\)]+)\s+([A-Z][a-zàèìòùáéíóú\s',;:.]{4,60})\s*\n/g,
        
        // Pattern per titoli semplici (riga breve che inizia con maiuscola seguita da riga vuota)
        /\n\s*([A-Z][a-zA-Z\s',;:.]{5,50})\s*\n\s*\n/g
    ];
    
    // Cerca match per ogni pattern
    let matches = [];
    
    for (const pattern of chapterPatterns) {
        let match;
        while ((match = pattern.exec(text)) !== null) {
            // Estrai il titolo del capitolo
            let chapterTitle;
            
            // Diversi gruppi di cattura in base al pattern
            if (match[3]) {
                // Pattern tipo "Capitolo 1: Titolo"
                chapterTitle = `${match[1]} ${match[2]}: ${match[3].trim()}`;
            } else if (match[2] && match[1].match(/^\d+[\.\)]$/)) {
                // Pattern tipo "1. Titolo"
                chapterTitle = match[2].trim();
            } else if (match[2]) {
                // Pattern tipo "Capitolo 1" con titolo o "1. Titolo"
                chapterTitle = `${match[1]} ${match[2].trim()}`;
            } else {
                // Pattern con solo il titolo
                chapterTitle = match[1].trim();
            }
            
            // Memorizza la posizione dell'inizio del capitolo
            matches.push({
                title: chapterTitle,
                startPosition: match.index,
                rawMatch: match[0],  // Salva il testo del match per analisi e pulizia
                type: 'chapter'
            });
        }
    }
    
    // Aggiungi un pattern per rilevare il testo prima di qualsiasi capitolo (frontmatter)
    if (matches.length > 0 && matches[0].startPosition > 100) {
        // C'è del testo significativo prima del primo capitolo
        const frontMatterText = text.substring(0, matches[0].startPosition);
        
        // Dividi il frontmatter in sezioni logiche
        detectFrontMatterSections(frontMatterText);
    }
    
    // Ordina i match per posizione
    matches.sort((a, b) => a.startPosition - b.startPosition);
    
    // Rimuovi i duplicati e i falsi positivi
    matches = cleanupChapterMatches(matches, text);
    
    // Crea i capitoli
    if (matches.length > 0) {
        for (let i = 0; i < matches.length; i++) {
            const startPos = matches[i].startPosition;
            const endPos = (i < matches.length - 1) ? matches[i+1].startPosition : text.length;
            
            // Ottieni il contenuto del capitolo escluso il titolo
            const titleLength = matches[i].rawMatch.length;
            const chapterContent = text.substring(startPos + titleLength, endPos).trim();
            
            chapters.push({
                title: matches[i].title,
                rawTitle: matches[i].rawMatch.trim(),
                startPosition: startPos,
                content: chapterContent,
                type: 'chapter'
            });
        }
    } else if (chapters.length === 0) {
        // Se non sono stati rilevati capitoli e non ci sono altre sezioni, crea un unico capitolo
        chapters = [{
            title: 'Intero documento',
            startPosition: 0,
            content: text,
            type: 'normal'
        }];
    }
    
    // Ordina tutti i capitoli e le sezioni per posizione
    chapters.sort((a, b) => a.startPosition - b.startPosition);
}

        // Funzione per rimuovere falsi positivi e combinare capitoli duplicati
function cleanupChapterMatches(matches, fullText) {
    if (matches.length <= 1) return matches;
    
    const cleanMatches = [];
    
    for (let i = 0; i < matches.length; i++) {
        // Calcola la distanza dal match precedente e successivo
        const prevDistance = i > 0 ? matches[i].startPosition - matches[i-1].startPosition : Infinity;
        const nextDistance = i < matches.length - 1 ? matches[i+1].startPosition - matches[i].startPosition : Infinity;
        
        // Se il titolo è molto vicino a un altro, potrebbe essere un falso positivo o parte dello stesso titolo
        if (prevDistance < 50) {
            // Probabilmente parte dello stesso titolo o falso positivo
            continue;
        }
        
        // Verifica se il titolo è isolato (non fa parte del testo corrente)
        const surroundingText = fullText.substring(
            Math.max(0, matches[i].startPosition - 50),
            Math.min(fullText.length, matches[i].startPosition + matches[i].rawMatch.length + 50)
        );
        
        // Se il titolo è circondato da troppo testo simile, potrebbe essere un falso positivo
        const isTitleIsolated = /\n\s*\n/.test(surroundingText.substring(0, 50)) || 
                                matches[i].startPosition < 50;
        
        if (!isTitleIsolated && matches[i].title.length < 15) {
            // Probabilmente un falso positivo (titolo troppo breve non isolato)
            continue;
        }
        
        // Verifica se il titolo è seguito da contenuto sufficiente
        const contentLength = i < matches.length - 1 
            ? matches[i+1].startPosition - (matches[i].startPosition + matches[i].rawMatch.length)
            : fullText.length - (matches[i].startPosition + matches[i].rawMatch.length);
        
        if (contentLength < 200 && i < matches.length - 1) {
            // Probabilmente un'intestazione invece di un capitolo vero
            continue;
        }
        
        // Questo sembra un titolo di capitolo valido
        cleanMatches.push(matches[i]);
    }
    
    return cleanMatches;
}
    // Aggiorna la lista dei capitoli nell'UI
    function updateChaptersList() {
        // Svuota la lista
        chaptersList.innerHTML = '';
        
        // Aggiungi ciascun capitolo
        chapters.forEach((chapter, index) => {
            const chapterItem = document.createElement('div');
            chapterItem.className = 'chapter-item';
            
            // Aggiungi un'icona o un indicatore per il tipo di sezione
            let typeIndicator = '';
            switch(chapter.type) {
                case 'chapter': typeIndicator = '📕 '; break;
                case 'title': typeIndicator = '📑 '; break;
                case 'colophon': typeIndicator = '©️ '; break;
                case 'dedication': typeIndicator = '❤️ '; break;
                case 'quote': typeIndicator = '💬 '; break;
                default: typeIndicator = '📄 ';
            }
            
            chapterItem.innerHTML = `
                <div>${typeIndicator}${index + 1}. ${chapter.title}</div>
                <div class="chapter-actions">
                    <button class="small-button" data-action="edit" data-index="${index}">Modifica</button>
                    <button class="small-button" data-action="delete" data-index="${index}">Elimina</button>
                </div>
            `;
            chaptersList.appendChild(chapterItem);
            
            // Aggiungi event listeners
            const editBtn = chapterItem.querySelector('[data-action="edit"]');
            const deleteBtn = chapterItem.querySelector('[data-action="delete"]');
            
            editBtn.addEventListener('click', () => openEditChapterModal(index));
            deleteBtn.addEventListener('click', () => deleteChapter(index));
        });
        
        // Aggiorna anche il selettore dei capitoli
        updateChapterSelect();
    }

    // Aggiorna il selettore dei capitoli
    function updateChapterSelect() {
        chapterSelect.innerHTML = '';
        
        chapters.forEach((chapter, index) => {
            const option = document.createElement('option');
            option.value = index;
            
            // Aggiungi un'icona o un indicatore per il tipo di sezione
            let typeIndicator = '';
            switch(chapter.type) {
                case 'chapter': typeIndicator = '📕 '; break;
                case 'title': typeIndicator = '📑 '; break;
                case 'colophon': typeIndicator = '©️ '; break;
                case 'dedication': typeIndicator = '❤️ '; break;
                case 'quote': typeIndicator = '💬 '; break;
                default: typeIndicator = '📄 ';
            }
            
            option.textContent = `${typeIndicator}${index + 1}. ${chapter.title}`;
            chapterSelect.appendChild(option);
        });
        
        // Carica il contenuto del primo capitolo se disponibile
        if (chapters.length > 0) {
            loadChapterContent();
        }
    }

    // Carica il contenuto del capitolo selezionato nell'editor
    function loadChapterContent() {
        const selectedIndex = parseInt(chapterSelect.value);
        if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= chapters.length) return;
        
        const chapter = chapters[selectedIndex];
        
        // Imposta il tipo di contenuto nei radio button
        const contentTypeRadio = document.querySelector(`input[value="${chapter.type}"]`);
        if (contentTypeRadio) {
            contentTypeRadio.checked = true;
        } else {
            document.querySelector('input[value="normal"]').checked = true;
        }
        
        textEditor.value = chapter.content;
        saveTextBtn.disabled = false;
    }

    // Aggiorna il tipo di contenuto del capitolo corrente
    function updateContentType(type) {
        const selectedIndex = parseInt(chapterSelect.value);
        if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= chapters.length) return;
        
        chapters[selectedIndex].type = type;
        updateChaptersList();
    }

    // Aggiungi un nuovo capitolo
    function addNewChapter() {
        currentEditingChapterIndex = -1;
        chapterTitle.value = '';
        chapterStartPosition.value = extractedText.length;
        sectionType.value = 'normal';
        openModal();
    }

    // Apri il modal per modificare un capitolo
    function openEditChapterModal(index) {
        currentEditingChapterIndex = index;
        const chapter = chapters[index];
        
        chapterTitle.value = chapter.title;
        chapterStartPosition.value = chapter.startPosition;
        sectionType.value = chapter.type || 'normal';
        
        openModal();
    }

    // Salva le modifiche al capitolo
    function saveChapterChanges() {
        const title = chapterTitle.value.trim();
        const startPos = parseInt(chapterStartPosition.value);
        const type = sectionType.value;
        
        if (!title) {
            showNotification('Inserisci un titolo per la sezione.', true);
            return;
        }
        
        if (isNaN(startPos) || startPos < 0 || startPos >= extractedText.length) {
            showNotification('Posizione di inizio non valida.', true);
            return;
        }
        
        if (currentEditingChapterIndex === -1) {
            // Nuovo capitolo
            const newChapter = {
                title: title,
                startPosition: startPos,
                content: extractedText.substring(startPos).trim(),
                type: type
            };
            
            chapters.push(newChapter);
            
            // Aggiorna i capitoli esistenti
            updateChapterBoundaries();
        } else {
            // Modifica di un capitolo esistente
            chapters[currentEditingChapterIndex].title = title;
            chapters[currentEditingChapterIndex].startPosition = startPos;
            chapters[currentEditingChapterIndex].type = type;
            
            // Aggiorna il contenuto in base alla nuova posizione
            updateChapterBoundaries();
        }
        
        // Aggiorna l'UI
        updateChaptersList();
        
        // Chiudi il modal
        closeModal();
    }

    // Aggiorna i confini dei capitoli dopo modifiche
    function updateChapterBoundaries() {
        // Ordina i capitoli per posizione
        chapters.sort((a, b) => a.startPosition - b.startPosition);
        
        // Aggiorna il contenuto di ciascun capitolo
        for (let i = 0; i < chapters.length; i++) {
            const startPos = chapters[i].startPosition;
            const endPos = (i < chapters.length - 1) ? chapters[i+1].startPosition : extractedText.length;
            
            chapters[i].content = extractedText.substring(startPos, endPos).trim();
        }
    }

    // Elimina un capitolo
    function deleteChapter(index) {
        if (chapters.length <= 1) {
            showNotification('Non è possibile eliminare l\'unica sezione presente.', true);
            return;
        }
        
        // Rimuovi il capitolo
        chapters.splice(index, 1);
        
        // Aggiorna l'UI
        updateChaptersList();
        
        showNotification('Sezione eliminata con successo.');
    }

    // Procedi alla fase di modifica del testo
    function goToEditStep() {
        goToStep(3);
        loadChapterContent();
    }

    // Salva le modifiche al testo del capitolo
    function saveTextChanges() {
        const selectedIndex = parseInt(chapterSelect.value);
        if (isNaN(selectedIndex) || selectedIndex < 0 || selectedIndex >= chapters.length) return;
        
        // Salva il contenuto modificato
        chapters[selectedIndex].content = textEditor.value;
        
        // Salva anche il tipo di contenuto
        const selectedType = document.querySelector('input[name="contentType"]:checked').value;
        chapters[selectedIndex].type = selectedType;
        
        showNotification('Modifiche salvate con successo.');
    }

    // Genera il file EPUB
    async function generateEpub() {
        try {
            // Salva le eventuali modifiche in corso
            saveTextChanges();
            
            // Mostra il loader
            generateEpubBtn.disabled = true;
            generateSpinner.classList.remove('spinner-hidden');
            generateSpinner.classList.add('spinner-visible');
            
            // Crea un nuovo file EPUB (ZIP)
            const zip = new JSZip();
            
            // Aggiungi il file mimetype (deve essere il primo e non compresso)
            zip.file('mimetype', 'application/epub+zip', { compression: 'STORE' });
            
            // Crea la struttura delle cartelle
            const metaInf = zip.folder('META-INF');
            const oebps = zip.folder('OEBPS');
            const textFolder = oebps.folder('text');
            const cssFolder = oebps.folder('css');
            const imagesFolder = oebps.folder('images');
            
            // Aggiungi il file container.xml
            metaInf.file('container.xml', `<?xml version="1.0" encoding="UTF-8"?>
            <container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
              <rootfiles>
                <rootfile full-path="OEBPS/content.opf" media-type="application/oebps-package+xml"/>
              </rootfiles>
            </container>`);
            
          // Aggiungi il CSS con stili migliorati per i vari tipi di contenuto
cssFolder.file('style.css', `
body {
    font-family: serif;
    margin: 5%;
    text-align: justify;
    line-height: 1.5;
}
h1, h2, h3, h4, h5, h6 {
    text-align: center;
    line-height: 1.2;
    margin: 1em 0;
}
.title {
    font-size: 2em;
    font-weight: bold;
    margin-bottom: 1em;
    text-align: center;
}
.author {
    font-size: 1.5em;
    text-align: center;
    margin-bottom: 2em;
}
.chapter {
    page-break-before: always;
}
.chapter-title {
    font-size: 1.5em;
    font-weight: bold;
    text-align: center;
    margin-bottom: 1.5em;
    margin-top: 1.5em;
}
p {
    text-indent: 1.5em;
    margin: 0;
}
.dedication {
    font-style: italic;
    text-align: center;
    margin: 2em 0;
    page-break-before: always;
}
.quote {
    font-style: italic;
    margin: 2em 5%;
    text-align: justify;
    page-break-before: always;
}
.quote .attribution {
    text-align: right;
    margin-top: 1em;
}
.colophon {
    font-size: 0.9em;
    text-align: center;
    margin: 2em 0;
    page-break-before: always;
}
.footnote {
    font-size: 0.9em;
    margin-top: 1em;
    border-top: 1px solid #ccc;
    padding-top: 0.5em;
}
.preserve-whitespace {
    white-space: pre-wrap;
}
.no-indent {
    text-indent: 0;
}
.centered {
    text-align: center;
    text-indent: 0;
}
.main-chapter {
    font-size: 1.1em;
}
.main-chapter .chapter-title {
    font-size: 1.7em;
    page-break-before: always;
}
`);
               
               // Crea la pagina di copertina
               const coverHtml = `<?xml version="1.0" encoding="UTF-8"?>
               <!DOCTYPE html>
               <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
               <head>
                   <meta charset="UTF-8"/>
                   <title>${escapeXml(bookTitle.value)}</title>
                   <link rel="stylesheet" type="text/css" href="../css/style.css"/>
               </head>
               <body>
                   <div class="title">${escapeXml(bookTitle.value)}</div>
                   ${bookAuthor.value ? `<div class="author">di ${escapeXml(bookAuthor.value)}</div>` : ''}
               </body>
               </html>`;
               
               textFolder.file('cover.xhtml', coverHtml);
               
               // Crea la pagina di titolo
               const titleHtml = `<?xml version="1.0" encoding="UTF-8"?>
               <!DOCTYPE html>
               <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
               <head>
                   <meta charset="UTF-8"/>
                   <title>${escapeXml(bookTitle.value)}</title>
                   <link rel="stylesheet" type="text/css" href="../css/style.css"/>
               </head>
               <body>
                   <div class="title">${escapeXml(bookTitle.value)}</div>
                   ${bookAuthor.value ? `<div class="author">di ${escapeXml(bookAuthor.value)}</div>` : ''}
                   ${bookDescription.value ? `<div class="dedication">${escapeXml(bookDescription.value)}</div>` : ''}
               </body>
               </html>`;
               
               textFolder.file('title.xhtml', titleHtml);
               
               // Crea i file dei capitoli
const chapterFiles = [];

// Raccogli tutti i capitoli veri (non elementi speciali)
const mainChapters = chapters.filter(ch => ch.type === 'chapter');

for (let i = 0; i < chapters.length; i++) {
    const chapter = chapters[i];
    const filename = `chapter${(i+1).toString().padStart(3, '0')}.xhtml`;
    
    // Formatta il contenuto in base al tipo di sezione
    let contentHtml = '';
    let chapterClass = '';
    let titleHtml = '';
    
    switch (chapter.type) {
        case 'dedication':
            contentHtml = formatDedication(chapter.content);
            chapterClass = 'dedication';
            titleHtml = `<h2>${escapeXml(chapter.title)}</h2>`;
            break;
            
        case 'quote':
            contentHtml = formatQuote(chapter.content);
            chapterClass = 'quote';
            titleHtml = `<h2>${escapeXml(chapter.title)}</h2>`;
            break;
            
        case 'colophon':
            contentHtml = formatColophon(chapter.content);
            chapterClass = 'colophon';
            titleHtml = `<h2>${escapeXml(chapter.title)}</h2>`;
            break;
            
        case 'title':
            contentHtml = formatTitle(chapter.content);
            chapterClass = 'title';
            titleHtml = '';  // Il titolo è già nel contenuto
            break;
            
        case 'chapter':
            // Verifica se è un capitolo numerato effettivo
            const isMainChapter = mainChapters.length > 1 && mainChapters.includes(chapter);
            chapterClass = isMainChapter ? 'chapter main-chapter' : 'chapter';
            
            // Testo formattato appropriatamente
            contentHtml = formatNormalText(chapter.content);
            
            // Titolo del capitolo con formattazione appropriata
            titleHtml = `<div class="chapter-title">${escapeXml(chapter.title)}</div>`;
            break;
            
        case 'normal':
        default:
            contentHtml = formatNormalText(chapter.content);
            chapterClass = 'normal';
            titleHtml = chapter.title !== 'Intero documento' ? 
                `<div class="chapter-title">${escapeXml(chapter.title)}</div>` : '';
            break;
    }
    
    const chapterHtml = `<?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
    <head>
        <meta charset="UTF-8"/>
        <title>${escapeXml(chapter.title)}</title>
        <link rel="stylesheet" type="text/css" href="../css/style.css"/>
    </head>
    <body>
        <div class="${chapterClass}">
            ${titleHtml}
            ${contentHtml}
        </div>
    </body>
    </html>`;
    
    textFolder.file(filename, chapterHtml);
    
    // Aggiungi alla lista dei file di capitolo solo quelli che dovrebbero apparire nell'indice
    if (chapter.type === 'chapter' || chapter.type === 'normal' || 
        chapter.type === 'dedication' || chapter.type === 'colophon') {
        chapterFiles.push({
            id: `chapter${i+1}`,
            filename: filename,
            title: chapter.title,
            type: chapter.type
        });
    }
}
               
            // Crea la Table of Contents
const tocHtml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
    <meta charset="UTF-8"/>
    <title>Indice</title>
    <link rel="stylesheet" type="text/css" href="../css/style.css"/>
</head>
<body>
    <div class="chapter-title">Indice</div>
    <nav epub:type="toc" id="toc">
        <ol>
            <li><a href="cover.xhtml">Copertina</a></li>
            <li><a href="title.xhtml">Frontespizio</a></li>
            ${chapterFiles.map(chapter => {
                // Aggiungi classi speciali o indentazione per l'indice in base al tipo
                let className = '';
                if (chapter.type === 'chapter') {
                    className = ' class="toc-chapter"';
                }
                return `<li${className}><a href="${chapter.filename}">${escapeXml(chapter.title)}</a></li>`;
            }).join('\n')}
        </ol>
    </nav>
</body>
</html>`;
               
               textFolder.file('toc.xhtml', tocHtml);
               
               // Crea il file NCX (Navigation Control file for XML) per la compatibilità
               const ncxContent = `<?xml version="1.0" encoding="UTF-8"?>
               <ncx xmlns="http://www.daisy.org/z3986/2005/ncx/" version="2005-1">
                   <head>
                       <meta name="dtb:uid" content="urn:uuid:${generateUUID()}"/>
                       <meta name="dtb:depth" content="1"/>
                       <meta name="dtb:totalPageCount" content="0"/>
                       <meta name="dtb:maxPageNumber" content="0"/>
                   </head>
                   <docTitle>
                       <text>${escapeXml(bookTitle.value)}</text>
                   </docTitle>
                   <navMap>
                       <navPoint id="navpoint-1" playOrder="1">
                           <navLabel>
                               <text>Copertina</text>
                           </navLabel>
                           <content src="text/cover.xhtml"/>
                       </navPoint>
                       <navPoint id="navpoint-2" playOrder="2">
                           <navLabel>
                               <text>Frontespizio</text>
                           </navLabel>
                           <content src="text/title.xhtml"/>
                       </navPoint>
                       ${chapterFiles.map((chapter, index) => 
                           `<navPoint id="navpoint-${index+3}" playOrder="${index+3}">
                               <navLabel>
                                   <text>${escapeXml(chapter.title)}</text>
                               </navLabel>
                               <content src="text/${chapter.filename}"/>
                           </navPoint>`
                       ).join('\n')}
                   </navMap>
               </ncx>`;
               
               oebps.file('toc.ncx', ncxContent);
               
               // Crea il file OPF (Open Packaging Format)
               const opfContent = `<?xml version="1.0" encoding="UTF-8"?>
               <package xmlns="http://www.idpf.org/2007/opf" unique-identifier="BookID" version="3.0">
                   <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
                       <dc:identifier id="BookID">urn:uuid:${generateUUID()}</dc:identifier>
                       <dc:title>${escapeXml(bookTitle.value)}</dc:title>
                       ${bookAuthor.value ? `<dc:creator>${escapeXml(bookAuthor.value)}</dc:creator>` : ''}
                       <dc:language>${escapeXml(bookLanguage.value)}</dc:language>
                       <dc:date>${new Date().toISOString().split('T')[0]}</dc:date>
                       <meta property="dcterms:modified">${new Date().toISOString().replace(/\.\d+Z$/, 'Z')}</meta>
                   </metadata>
                   <manifest>
                       <item id="ncx" href="toc.ncx" media-type="application/x-dtbncx+xml"/>
                       <item id="nav" href="text/toc.xhtml" properties="nav" media-type="application/xhtml+xml"/>
                       <item id="css" href="css/style.css" media-type="text/css"/>
                       <item id="cover" href="text/cover.xhtml" media-type="application/xhtml+xml"/>
                       <item id="title" href="text/title.xhtml" media-type="application/xhtml+xml"/>
                       ${chapterFiles.map(chapter => 
                           `<item id="${chapter.id}" href="text/${chapter.filename}" media-type="application/xhtml+xml"/>`
                       ).join('\n')}
                   </manifest>
                   <spine toc="ncx">
                       <itemref idref="cover"/>
                       <itemref idref="title"/>
                       <itemref idref="nav"/>
                       ${chapterFiles.map(chapter => 
                           `<itemref idref="${chapter.id}"/>`
                       ).join('\n')}
                   </spine>
               </package>`;
               
               oebps.file('content.opf', opfContent);
               
               // Genera il file ZIP
               const epubContent = await zip.generateAsync({
                   type: 'blob',
                   mimeType: 'application/epub+zip',
                   compression: 'DEFLATE',
                   compressionOptions: { level: 9 }
               });
               
               // Memorizza il blob per il download
               epubBlob = epubContent;
               
               // Vai al passo finale
               goToStep(4);
               
           } catch (error) {
               console.error('Errore nella generazione dell\'EPUB:', error);
               showNotification('Si è verificato un errore durante la generazione dell\'EPUB. ' + error.message, true);
           } finally {
               // Nascondi il loader
               generateSpinner.classList.remove('spinner-visible');
               generateSpinner.classList.add('spinner-hidden');
               generateEpubBtn.disabled = false;
           }
       }

      function formatNormalText(text) {
    // Dividi in paragrafi
    const paragraphs = text.split(/\n\s*\n/);
    let html = '';
    
    for (const paragraph of paragraphs) {
        if (paragraph.trim()) {
            // Verifica se è un paragrafo centrato (tutto maiuscolo o inizia con * o simili)
            if (/^[A-ZÀÈÌÒÙ\s,.;:'"!?0-9]+$/.test(paragraph) || 
                /^[*\s_-]+/.test(paragraph)) {
                html += `<p class="centered">${escapeXml(paragraph.trim())}</p>\n`;
            } 
            // Verifica se è un paragrafo senza indentazione (inizia con tab o spazi)
            else if (/^\s+/.test(paragraph)) {
                html += `<p class="no-indent">${escapeXml(paragraph.trim())}</p>\n`;
            } 
            // Paragrafo normale
            else {
                html += `<p>${escapeXml(paragraph.trim())}</p>\n`;
            }
        }
    }
    
    return html;
}

       // Formatta una dedica
       function formatDedication(text) {
           return `<div class="dedication">${escapeXml(text.trim())}</div>`;
       }

       // Formatta una citazione
       function formatQuote(text) {
           const lines = text.split('\n');
           let quoteText = '';
           let attribution = '';
           
           // Cerca di separare la citazione dall'attribuzione
           const attributionIndex = text.lastIndexOf('—');
           if (attributionIndex !== -1) {
               quoteText = text.substring(0, attributionIndex).trim();
               attribution = text.substring(attributionIndex).trim();
               
               return `<div class="quote">
                   <div class="quote-text">${escapeXml(quoteText)}</div>
                   <div class="attribution">${escapeXml(attribution)}</div>
               </div>`;
           } else {
               return `<div class="quote">${escapeXml(text.trim())}</div>`;
           }
       }

       // Formatta un colophon
       function formatColophon(text) {
           // Preserva gli a capo nel colophon
           return `<div class="colophon preserve-whitespace">${escapeXml(text.trim())}</div>`;
       }

       // Formatta un titolo
       function formatTitle(text) {
           // Preserva la formattazione originale per i titoli
           return `<div class="title preserve-whitespace">${escapeXml(text.trim())}</div>`;
       }

       // Scarica il file EPUB
       function downloadEpub() {
           if (!epubBlob) {
               showNotification('Nessun file EPUB generato. Riprova.', true);
               return;
           }
           
           // Crea un URL per il download
           const url = URL.createObjectURL(epubBlob);
           
           // Crea un elemento link per il download
           const a = document.createElement('a');
           a.href = url;
           a.download = `${bookTitle.value || 'libro'}.epub`;
           document.body.appendChild(a);
           
           // Simula il click per avviare il download
           a.click();
           
           // Rimuovi l'elemento e rilascia l'URL
           setTimeout(() => {
               document.body.removeChild(a);
               URL.revokeObjectURL(url);
           }, 100);
           
           showNotification('Download avviato con successo!');
       }

       // Resetta l'applicazione
       function resetApp() {
           // Resetta le variabili globali
           currentPdfFile = null;
           extractedText = '';
           pdfDocument = null;
           chapters = [];
           currentEditingChapterIndex = -1;
           epubBlob = null;
           
           // Resetta l'UI
           fileInfo.style.display = 'none';
           progressContainer.style.display = 'none';
           progressBar.style.width = '0%';
           textEditor.value = '';
           
           // Disabilita i pulsanti
           extractTextBtn.disabled = true;
           saveTextBtn.disabled = true;
           proceedToEditBtn.disabled = true;
           
           // Resetta i campi
           bookTitle.value = '';
           bookAuthor.value = '';
           bookDescription.value = '';
           bookLanguage.value = 'it';
           
           // Torna al primo passo
           goToStep(0);
       }

       // Passa a un determinato step
       function goToStep(stepIndex) {
           // Aggiorna la classe active
           steps.forEach((step, index) => {
               if (index <= stepIndex) {
                   step.classList.add('active');
               } else {
                   step.classList.remove('active');
               }
           });
       }

       // Utility per aprire un modal
       function openModal() {
           chapterModal.style.display = 'flex';
       }

       // Utility per chiudere un modal
       function closeModal() {
           chapterModal.style.display = 'none';
       }

       // Mostra una notifica
       function showNotification(message, isError = false) {
           notification.textContent = message;
           notification.className = 'notification' + (isError ? ' error' : '');
           
           // Mostra la notifica
           notification.classList.add('show');
           
           // Nascondi la notifica dopo 3 secondi
           setTimeout(() => {
               notification.classList.remove('show');
           }, 3000);
       }

       // Utility per leggere un file come ArrayBuffer
       function readFileAsArrayBuffer(file) {
           return new Promise((resolve, reject) => {
               const reader = new FileReader();
               reader.onload = () => resolve(reader.result);
               reader.onerror = reject;
               reader.readAsArrayBuffer(file);
           });
       }

       // Utility per formattare la dimensione del file
       function formatFileSize(bytes) {
           if (bytes < 1024) {
               return bytes + ' B';
           } else if (bytes < 1024 * 1024) {
               return (bytes / 1024).toFixed(2) + ' KB';
           } else {
               return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
           }
       }

       // Utility per generare un UUID
       function generateUUID() {
           return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
               const r = Math.random() * 16 | 0;
               const v = c === 'x' ? r : (r & 0x3 | 0x8);
               return v.toString(16);
           });
       }

       // Utility per escape dei caratteri XML
       function escapeXml(unsafe) {
           if (!unsafe) return '';
           return unsafe
               .replace(/&/g, '&amp;')
               .replace(/</g, '&lt;')
               .replace(/>/g, '&gt;')
               .replace(/"/g, '&quot;')
               .replace(/'/g, '&apos;');
       }
   </script>
</body>
</html>
